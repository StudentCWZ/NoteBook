/*
* @Author: StudentCWZ
* @Date:   2020-06-09 09:48:35
* @Last Modified by:   StudentCWZ
* @Last Modified time: 2020-06-09 10:00:38
*/


public class DataTypeTest05
{
  public static void main(String[] args){

    //100L是long类型字面值
    //x是long类型变量
    //不存在类型转换，直接赋值
    long x = 100L;

    //x变量是long类型，8个字节
    //y变量是int类型，4个字节
    //编译报错，大容量不能直接赋值给小容量
    //in y = x;

    //大容量转换成小容量，需要进行强制类型转换
    //强制类型转换需要加“强制类型转换符”
    //加上强制类型转换符之后编译通过了，但是运行阶段可能会损失精度。
    //所以强制类型转换谨慎使用，因为损失精度后，可能损失很严重。


    //强转原理：
      //原始数据：00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100100
      //强转之后的数据：00000000 00000000 00000000 01100100
      //将左边的二进制砍掉【所有数据强转的时候都是这样完成的】
    int y = (int)x;
    System.out.println(y);


    //原始数据：00000000 00000000 00000000 00000000 10000000 00000000 00000000 00000000
    //强转之后的数据：10000000 00000000 00000000 00000000 目前存储在计算机内部，计算机存储数据都是采用补码的形式存储。
    //所以10000000 00000000 00000000 00000000是一个补码形式
    //将以上的补码转换到原码，就是最终的结果。
    long k = 2147483648L;
    int e = (int)k;
    System.out.println(e);//损失精度非常严重，结果是负数。


    //根据目前所学内容，以下程序是无法编译通过
    //理由：50是int类型的字面值，b是byte类型的变量，显然是大容量int转换成小容量byte
    //大容量转换成小容量是需要添加强制类型转换符的，以下程序没有添加强转符号，所以编译报错。
    //但是，在实际编译的时候，以下代码编译通过了，这说明：在java语法当中，当一个整数型字面值没有超出byte类型的取值范围，该字面值可以直接赋值给byte类型变量。
    byte b = 50;//可以

    byte c = 127;//可以

    //编译报错，128这个int类型字面值已经超出了byte类型的取值范围，不能直接赋值给byte类型的变量
    //byte b1 = 128;//不可以

    //纠正错误，需要使用强制类型转换符
    //但是一定会损失精度
    //原始数据：00000000 00000000 00000000 10000000
    //强转之后：10000000【这是存储在计算机内部的，这是一个补码】
    byte b1 = (byte)128;
    System.out.println(b1);//-128

    /*
      计算机二进制有三种表示方式：
        原码
        反码
        补码
      计算机在任何情况下底层表示和存储数据的时候采用了补码形式。
      正数的补码：和原码相同
      负数的补码：负数的绝对值对应的二进制码所有二进制取反，再加1
      补码：10000000
      原码的计算过程：
        * 10000000 - 1--> 01111111
        * 01111111-->10000000-->128
        * -128
    */

    //原始数据：00000000 00000000 00000000 11000110
    //强转之后：11000110
    //11000110现在在计算机当中存储，它是一个补码，将补码转换成原码就是该数字。
    //11000110 - 1 --> 11000101
    //00111010 --> 58
    //-58
    byte m = (byte)198;
    System.out.println(m);//-58

    //short s = 32767;//通过
    //short s1 = 32768;//编译报错

    //65535是int类型，4个字节
    //cc是char类型，2个字节
    //按照以前所学知识点来说，以下程序是编译报错的。
    //char cc = 65535; //通过
    //char cc = 65535; //编译报错

    /*
      当一个整数字面值没有超出byte,short,char的取值范围，这个字面值可以直接赋值给byte，short，char类型的变量。这种机制SUN允许了，目的是为了方便程序员的编程。
    */

  }
}

