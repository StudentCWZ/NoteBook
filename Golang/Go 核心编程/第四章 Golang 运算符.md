# Golang 运算符
## 运算符介绍
### 运算符的相关介绍
1. 运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。
```
(1) 算术运算符
(2) 赋值运算符
(3) 比较运算符/关系运算符
(4) 逻辑运算符
(5) 位运算符
(6) 其他运算符
```

### 算术运算符
1. 算术运算符是对数值型变量进行运算的，比如：加减乘除。
2. 算术运算符一览

|运算符|运算|范例|结果|
|:--:|:--:|:--:|:--:|
|+|正号|+3|3|
|-|负号|-4|-4|
|+|加|5 + 5|10|
|-|减|6 - 4|2|
|&#42;|乘|3 &#42; 4`|12|
|/|除|5 / 5|1|
|%|取模(取余)|7 % 5|2|
|++|自增|a = 2 a++|a=3|
|--|自减|a = 2 a--|a=1|
|+|字符串|"He" + "llo"|"Hello"|

3. 除法使用的特点
```
package main

import "fmt" // fmt 包中提供格式化、输出、输入的函数


func main()  {
	//重点讲解 /、%
	//说明：如果参与运算的数都是整数，那么除后，去掉小数部分，保留整数部分。
	fmt.Println(10 / 4) // 2.5
	var n1 float32 = 10 / 4
	fmt.Println(n1)

	//如果我们希望保留小数部分，则需要有浮点数参与运算。
	var n2 float32 = 10.0 / 4
	fmt.Println(n2)
}
```
4. 取模使用特点
```
package main

import "fmt" // fmt 包中提供格式化、输出、输入的函数


func main()  {
	//演示 % 的使用
	//看一个公式 a % b = a - a / b * b
	fmt.Println("10 % 3 =", 10 % 3) // =1
	fmt.Println("-10 % 3 =", -10 % 3) // = -10 - (-10) / 3 * 3 = -1
	fmt.Println("10 % -3 =", 10 % -3) // = 10 - (10) / (-3) * (-3) = 1
	fmt.Println("-10 % -3 =", -10 % -3) // = (-10) - (-10) / (-3) * (-3) = -1
}
```
5. 自增、自减运算符使用特点
```
package main

import "fmt" // fmt 包中提供格式化、输出、输入的函数


func main()  {
	// ++ 和 -- 的使用
	var i int = 10
	i++ // 等价 i = i + 1
	fmt.Println("i =",i)
	i-- // 等价 i = i - 1
	fmt.Println("i =",i)
}
```

#### 算术运算符的细节说明
1. 对于除号 / ，它的整数除和小数除是有区别的：整数之间做除法时，只保留整数部分而舍弃小数部分。例如：x := 19 / 5，结果是 3 。
2. 当对一个数取模时，可以等价 a % b = a-a / b * b，这样我们可以看到取模的一个本质运算。
3. Golang 的自增自减只能当做一个独立语言使用，不能这样使用：b := a++ 或者 b := a-- 。
```
package main

import "fmt" // fmt 包中提供格式化、输出、输入的函数


func main()  {
	//在 Golang 中，++ 和 -- 只能独立使用。
	var i int = 8
	var a int
	var b int
	// a = i++ //错误，i++ 只能独立使用。
	// a = i-- //错误，i-- 只能独立使用。
	i++
	a = i
	fmt.Println(a)
	i--
	b = i
	fmt.Println(b)

}
```
4. Golang 的 ++ 和 -- 只能写在变量的前面，即：只有 a++ a-- 没有 ++a --a。
```
package main

import "fmt" // fmt 包中提供格式化，输出，输入的函数


func main()  {
	//在 Golang 中，++ 和 -- 只能独立使用。
	var i int = 8
	var a int
	var b int
	// a = i++ //错误，i++ 只能独立使用。
	// a = i-- //错误，i-- 只能独立使用。
	i++
	a = i
	fmt.Println(a)
	i--
	b = i
	fmt.Println(b)

	//Golang 的 ++ 和 -- 只能写在变量的前面
	var j int = 1
	j++
	//++j 错误
	//--j 错误
	fmt.Println("j =", j)
}
```
5. Golang 的设计者去掉 C/Java 中自增自减的容易混淆的写法，让 Golang 更加简洁，统一(强制性的)。
6. 相关练习
```
package main

import "fmt" // fmt 包中提供格式化、输出、输入的函数


func main()  {
	//假如还有97天放假，问：XX个星期零XX天
	var days int = 97
	var week int = days / 7
	var day int = days % 7
	fmt.Printf("%d 个星期零 %d 天 \n", week, day)


	//定义一个变量保存华氏温度，华氏温度转换摄氏温度的公式为：5.0 / 9 * (华氏温度 - 100)，请求出华氏温度对应的摄氏温度。
	var huashi float32 = 134.2
	var sheshi float32 = 5.0 / 9 * (huashi - 100)
	fmt.Printf("华氏温度：%v 对应的摄氏温度：%v \n", huashi, sheshi)

}
```

### 关系运算符(比较运算符)
#### 关系运算符的基本介绍
1. 关系运算符的结果都是 bool 型，也就是要么是 true ，要么是 false 。
2. 关系表达式经常用在 if 结构的条件中或循环结果的条件中。

#### 关系运算符一览

|运算符|运算|范例|结果|
|:--:|:--:|:--:|:--:|
|==|相等于|4 == 3|false|
|!=|不等于|4 != 3|true|
|<|小于|4 &#60; 3|false|
|>|大于|4 > 3|true|
|<=|小于等于|4 <= 3|false|
|>=|大于等于|4 >= 3|true|

#### 案例演示
```
package main

import "fmt" // fmt 包中提供格式化、输出、输入的函数


func main()  {
	//演示关系运算符的使用
	var n1 int = 9
	var n2 int = 8
	fmt.Println(n1 == n2) // false
	fmt.Println(n1 != n2) // true
	fmt.Println(n1 > n2) // true
	fmt.Println(n1 >= n2) // true
	fmt.Println(n1 < n2) // false
	fmt.Println(n1 <= n2) // false
	flag := n1 > n2
	fmt.Println("flag =", flag)
}
```

#### 关系运算符细节说明
1. 关系运算符的结果都是 bool 型，也就是要么是 true，要么是 false 。
2. 关系运算符责成的表达式，我们称为关系表达式: a > b
3. 比较运算符 == 不能误写成 = 。

### 逻辑运算符
#### 基本介绍
1. 用于连接多个条件(一般来讲就是关系表达式)，最终结果也是一个 bool 值。

#### 逻辑运算符一览
1. 假定 A 值为 True ，B 值为 False 。

|运算符|描述|实例|
|:--:|:--:|:--:|
|&#38;&#38;|逻辑与运算符。如果两边的操作都是 True，则为 True，否则为 false 。|(A&#38;&#38;B) 为 False|
|&#124;&#124;|逻辑或运算符。如果两边的操作数有一个 True，则为 True，否则为 False 。|(A&#124;&#124;B) 为 True|
|&#33;|逻辑非运算符。如果条件为 True ，则逻辑非为 False ，否则为 True |&#33;(A&#38;&#38;B) 为 True| 

#### 相关案例
```
package main

import "fmt" // fmt 包中提供格式化、输出、输入的函数


func main()  {
	//演示逻辑运算符的使用 &&
	var age int = 40
	if age > 30 && age < 50 {
		fmt.Println("ok1")
	}


	if age > 30 && age < 40 {
		fmt.Println("ok2")
	}

	//演示逻辑运算符的使用 ||
	if age > 30 || age < 50 {
		fmt.Println("ok3")
	}


	if age > 30 || age < 40 {
		fmt.Println("ok4")
	}

	//演示逻辑运算符的使用 !
	if age > 30 {
		fmt.Println("ok5")
	}


	if !(age > 30) {
		fmt.Println("ok6")
	}

}
```

#### 逻辑运算符注意事项和细节说明
1. && 也叫短路与：如果第一个条件为 false ，则第二个条件不会判断，最终结果为 false 。
```
package main

import "fmt" // fmt 包中提供格式化、输出、输入的函数


//声明一个函数(测试)
func test() bool{
	fmt.Println("test...")
	return true
}

func main()  {

	var i int = 10

	if i < 9 && test() {
		fmt.Println("ok")
	}
}
```
2. || 也叫短路或: 如果第一个条件为 true ，则第二个条件不会判断，最终结果为 true 。
```
package main

import "fmt" // fmt 包中提供格式化、输出、输入的函数


//声明一个函数(测试)
func test() bool{
	fmt.Println("test...")
	return true
}

func main()  {

	var i int = 10

	if i > 9 || test() {
		fmt.Println("hello...")
	}
}
```

### 赋值运算符
1. 赋值运算符就是将某个运算后的值，赋给指定的变量。

#### 赋值运算符的分类
1. 赋值运算符的分类

|运算符|描述|实例|
|:--:|:--:|:--:|
|=|简单的赋值运算符，将一个表达式的值赋给一个左值|C = A + B 将 A+B 表达式结果赋值给 C|
|+=|相加后再赋值|C += A 等于 C = C + A|
|-=|相减后再赋值|C -= A 等于 C = C - A|
|&#42;&#61;|相乘后再赋值|C &#42;&#61; A 等于 C = C &#42; A|
|/=|相除后再赋值|C /= A 等于 C = C / A|
|%=|求余后再赋值|C %= A 等于 C = C % A|
|<<=|左移后赋值|C &#60;&#60;= 2 等于 C = C &#60;&#60; 2|
|&=|按位与后赋值|C &= 2 等于 C = C & 2|
|^=|按位异或后赋值|C ^= 2 等于 C = C ^ 2|
|&#124;=|按位或后赋值|C &#124;= 2 等于 C = C &#124; 2|

2. 说明：这部分的赋值运算涉及到二进制相关知识，我们放在讲二进制的时间再回头讲解。
3. 相关案例
```
package main

import "fmt" // fmt 包中提供格式化、输出、输入的函数



func main()  {
	//赋值运算符的使用演示
	var i int
	i = 10 //基本赋值
	fmt.Println("i =", i)

	//有两个变量，a 和 b，要求将其进行交换，最终打印结果。
	// a = 9, b = 2 ==> a = 2, b = 9
	a := 9
	b := 2
	fmt.Printf("交换前的情况下是 a = %v , b = %v \n", a, b)
	//定义一个临时变量
	t := a
	a = b //
	b = t
	fmt.Printf("交换后的情况下是 a = %v , b = %v \n", a, b)

	//复合赋值的操作
	a += 17 //等价 a = a + 17
	fmt.Println("a =", a)

}
```

#### 赋值运算符特点
1. 运算顺序从右往左
2. 赋值运算符的左边，只能是变量，右边可以是变量、表达式、常量值。
3. 复合赋值运算符等价于下面的效果。比如：a += 3 等价于 a = a + 3
4. 相关案例
```
package main

import "fmt" // fmt 包中提供格式化、输出、输入的函数

func test() int {
	return 90
}

func main()  {
	//赋值运算符的使用演示
	var i int
	i = 10 //基本赋值
	fmt.Println("i =", i)

	//有两个变量，a 和 b，要求将其进行交换，最终打印结果。
	// a = 9, b = 2 ==> a = 2, b = 9
	a := 9
	b := 2
	fmt.Printf("交换前的情况下是 a = %v , b = %v \n", a, b)
	//定义一个临时变量
	t := a
	a = b 
	b = t
	fmt.Printf("交换后的情况下是 a = %v , b = %v \n", a, b)

	//复合赋值的操作
	a += 17 //等价 a = a + 17
	fmt.Println("a =", a)

	//赋值运算符的左边，只能是变量，右边可以是变量、表达式、常量值。
	//表达式：任何有值都可以看做表达式
	var d int
	d = a //
	d = 8 + 2 * 8 // =的右边是表达式
	d = test() + 90 // =的右边是表达式
	d = 890 // 890 常量
	fmt.Println(d)
}
```
5. 相关练习
```
package main

import "fmt" // fmt 包中提供格式化、输出、输入的函数


func main()  {
	//有两个变量，a 和 b，要求将其进行交换，但是不允许使用中间变量，最终打印结果
	var a int = 10
	var b int = 20

	a = a + b //
	b = a - b // b = a + b - b ==> b = a
	a = a - b // a = a + b - a ==> a = b

	fmt.Printf("a = %v b = %v", a, b)

}
```

### 运算符的优先级
1. 运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。如右表，上一行运算符总优先于下一行。
2. 只有单目运算符、赋值运算符是从右向左运算的。
3. 大致顺序整理
```
(1) 括号, ++， --
(2) 单目运算
(3) 算术运算
(4) 移位运算
(5) 关系运算
(6) 位运算
(7) 逻辑运算
(8) 赋值运算符
(9) 逗号
```

|分类|描述|关联性|
|:--:|:--:|:--:|
|后缀|`() [] -> . ++ --`|左到右|
|单目|`+ - ! ~ (type) * & sizeof`|右到左|
|乘法|`*/%`|左到右|
|加法|`+ -`|左到右|
|移位|`<< >>`|左到右|
|关系|`< <= > >=`|左到右|
|相等(关系)|`== !=`|左到右|
|按位AND|`&`|左到右|
|按位XOR|`&`|左到右|
|按位OR|&#124;|左到右|
|逻辑AND|`&&`|左到右|
|逻辑OR|&#124;&#124;|左到右|
|赋值运算符|`= += -= *= /= %= >>= <<= &= ^=`|右到左|
|逗号|`,`|左到右|

### 其他运算符
#### 其他运算符说明
1. 其他运算符说明

|运算符|描述|实例|
|:--:|:--:|:--:|
|`&`|返回变量存储地址|`&a;`将给出变量的实际地址|
|`*`|指针变量|`*a;`将给出变量的实际地址|

2. Go 语言明确不支持三元运算符。
3. 相关案例
```
package main

import "fmt" // fmt 包中提供格式化，输出，输入的函数


func main()  {
	//演示 & 和 * 的使用

	a := 100
	fmt.Println("a 的地址 =", &a)

	var ptr *int = &a
	fmt.Println("*ptr 指向的值 =", *ptr)

	var n int
	var i int = 10
	var j int = 12

	//传统的三元运算符
	//n = i > j ? i : j
	if i > j {
		n = i
	} else {
		n = j
	}
	fmt.Println("n = ", n)
}
```

### 键盘输入语句
#### 基本介绍
1. 在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。

#### 步骤
1. 导入fmt 包
2. 调用 fmt 包的 fmt.Scanln() 或者 fmt.Scanf()

#### 相关案例
1. 方式1：fmt.scanln
```
package main

import "fmt" // fmt 包中提供格式化、输出、输入的函数


func main()  {
	//要求：可以从控制台接收用户信息，其中包括：姓名，年龄，薪水，是否通过考试。
	//方式1 fmt.scanln
	//1. 先声明需要的变量
	var name string
	var age byte
	var sal float32
	var isPass bool
	//当程序执行到 fmt.Scaln(&name) ，程序会停止在这里，等待用户输入，并回车
	fmt.Println("请输入姓名 ")
	fmt.Scanln(&name)

	fmt.Println("请输入年龄 ")
	fmt.Scanln(&age)

	fmt.Println("请输入薪水 ")
	fmt.Scanln(&sal)

	fmt.Println("请输入是否通过考试")
	fmt.Scanln(&isPass)

	fmt.Printf("名字是 %v \n 年龄是 %v \n 薪水是 %v \n 是否通过考试 %v \n", name, age, sal, isPass)
}
```
2. 方式2：fmt.Scanf，可以按指定的格式输入
```
package main

import "fmt" // fmt 包中提供格式化、输出、输入的函数


func main()  {
	//要求：可以从控制台接收用户信息，其中包括：姓名，年龄，薪水，是否通过考试。
	//1. 先声明需要的变量
	var name string
	var age byte
	var sal float32
	var isPass bool
	
	
	//方式2：fmt.Scanf，可以按指定的格式输入
	fmt.Println("请输入你的姓名，年龄，薪水，是否通过考试， 使用空格隔开")
	fmt.Scanf("%s %d %f %t", &name, &age, &sal, &isPass)
	fmt.Printf("名字是 %v \n 年龄是 %v \n 薪水是 %v \n 是否通过考试 %v \n", name, age, sal, isPass)
}
```

### 进制
#### 进制的介绍
1. 对于整数，有四种表示方式：
```
(1) 二进制：0，1，满 2 进 1。
在 Golang 中，不能直接使用二进制来表示一个整数，它沿用了 C 的特点。
(2) 十进制：0-9，满 10 进 1 。
(3) 八进制：0-7， 满 8 进 1 。
在 Golang 中，可以直接使用八进制来表示一个整数。
(4) 十六进制：0-9 及 A-F，满 16 进 1 。以 0x 或者 0X 开头表示。
此处的 A-F 不区分大小写
如: 0x21AF + 1 = 0X21B0
```
2. 相关案例
```
package main

import "fmt" // fmt 包中提供格式化、输出、输入的函数

//演示进制
func main()  {

	var i int = 5
	//二进制输出
	fmt.Printf("%b \n", i)

	//八进制：0-7， 满 8 进 1 。
	var j int = 011 // 011 => 9
	fmt.Println("j =", j)

	//十六进制：0-9 及 A-F，满 16 进 1 。以 Ox 或 Ox 开头表示。
	var k int = 0x11 // 0x11 => 16 + 1 = 17
	fmt.Println("k =", k)
}
```
3. 进制图示

|十进制|十六进制|八进制|二进制|
|:--:|:--:|:--:|:--:|
|0|0|0|0|
|1|1|1|1|
|2|2|2|10|
|3|3|3|11|
|4|4|4|100|
|5|5|5|101|
|6|6|6|110|
|7|7|7|111|
|8|8|10|1000|
|9|9|11|1001|
|10|A|12|1010|
|11|B|13|1011|
|12|C|14|1100|
|13|D|15|1101|
|14|E|16|1110|
|15|F|17|1111|
|16|10|20|10000|
|17|11|21|10001|

#### 进制的转换
##### 进制转换的介绍
1. 第一组(其他进制转十进制)
```
(1) 二进制转十进制
规则：从最低位开始(右边的)，将每个位上的数提取出来，乘以 2 的(位数 - 1)次方，然后求和。
(2) 八进制转十进制
规则：从最低位开始(右边的)，将每个位上的数提取出来，乘以 8 的(位数 - 1)次方，然后求和。
(3) 十六进制转十进制
规则：从最低位开始，将每个位上的数提取出来，乘以 16 的(位数 - 1)次方，然后求和。
```
2. 第二组(十进制转其他进制)
```
(1) 十进制转二进制
规则：将该数不断除以 2，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的二进制。
(2) 十进制转八进制
规则：将该数不断除以 8，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的八进制。
(3) 十进制转十六进制
规则：将该数不断除以 16，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的十六进制。
```
3. 第三组(二进制转其他进制)
```
(1) 二进制转八进制
规则：将二进制数每三位一组(从低位开始组合)，转成对应的八进制数即可。
(2) 二进制转十六进制
规则：将二进制数每四位一组(从低位开始组合)，转成对应的十六进制数即可。
```
4. 第四组(其他进制转二进制)
```
(1) 八进制转二进制
规则：将八进制数每 1 位，转成对应的一个 3 位的二进制数即可。
(2) 十六进制转二进制
规则：将十六进制每 1 位，转成对应的一个 4 位的二进制数即可。
```

#### 二进制在运算中的说明
1. 二进制是逢 2 进位的进位制，0，1 是基本算符。
2. 现代的电子计算机技术全部采用的是二进制，因为它只使用 0、1 两个数字符号，非常简单方便，易于用电子方式实现。计算机内部处理的信息，都是采用二进制数来表示的。二进制(Binary)数用 0 和 1 两个数字及其组合来表示任何数，进位规则是“逢 2 进 1”，数字 1 在不同的位上代表不同的值，按从右至左的次序，这个值以二倍递增。

#### 原码、反码、补码
1. 网上对原码，反码，补码的解释过于复杂，这里精简几句话：
```
(1) 二进制的最高位是符号位：0 表示正数，1 表示负数
(2) 正数的原码，反码，补码都一样。
(3) 负数的反码 = 它的原码符号位不变，其他位取反(0->1, 1->0)
(4) 负数的补码 = 它的反码 + 1
(5) 0 的反码，补码都是 0
(6) 在计算机运算时候，都是以补码的方式运算的。
```

### 位运算符
#### 位运算符一览

|运算符|描述|
|:--:|:--:|
|`&`|按位与运算符 `&` 是双目运算符。其功能是参与运算的两数各对应的二进位相与。运算规则是：同时为 1，结果为 1，否则为 0|
|&#124;|按位或运算符 &#124; 是双目运算符。其功能是参与运算的两数各对应的二进制相或。运算规则是：有一个为 1，结果为 1，否则为 0。|
|`^`|按位异或运算符 `^` 是双目运算符。其功能是参与运算的两数各对应的二进位相异或。运算规则是：当二进位不同时，结果为 1，否则为 0|
|`<<`|左移运算符 `<<` 是双目运算符。其功能把 `<<` 左边的运算数的各二进位全部左移若干位，高位丢弃，低位补 0。左移 n 位就是乘以 2 的 n 次方。|
|`>>`|右移运算符 `>>` 是双目运算符。其功能是把 `>>` 左边的运算数的各个二进位全部右移若干位右移 n 位就是除以 2 的 n 次方。|

#### 位运算符合和移位运算符
1. Golang 中有 3 个位运算
```
(1) 按位与&: 两位全为 1 ，结果为 1 ，否则为 0
(2) 按位或|: 两位有一个为 1 ，结果为 1 ，否则为 0
(3) 按位异或^: 两位一个为 0，一个为 1，结果为 1，否则为 0
```
2. 相关案例
```
package main

import "fmt" // fmt 包中提供格式化、输出、输入的函数

//演示位运算
func main()  {

	//位运算的演示
	fmt.Println(2&3) // 2

	fmt.Println(2|3) // 3

	fmt.Println(2^3) // 1

	//-2 原码：[1000 0010]  反码：[1111 1101]  补码：[1111 1110]
	//2  原码：[0000 0010]  反码：[0000 0010]  补码：[0000 0010]
	//-2^2: [1111 1100](补码) ==> 反码：[1111 1011]  原码：[1000 0100]
	fmt.Println(-2^2) // -4

}
```
3. Golang中有 2 个移位运算符
```
>>、<<右移和左移，运算规则：
(1) 右移运算符 >>: 低位溢出，符号位不变，并用符号位补溢的高位。
(2) 左移运算符 <<: 符号位不变，低位补 0
```
4. 相关案例
```
package main

import "fmt" // fmt 包中提供格式化、输出、输入的函数

//演示位运算
func main()  {

	//位运算的演示
	fmt.Println(2&3) // 2

	fmt.Println(2|3) // 3

	fmt.Println(2^3) // 1

	//-2 原码：[1000 0010]  反码：[1111 1101]  补码：[1111 1110]
	//2  原码：[0000 0010]  反码：[0000 0010]  补码：[0000 0010]
	//-2^2: [1111 1100](补码) ==> 反码：[1111 1011]  原码：[1000 0100]
	fmt.Println(-2^2) // -4

	a := 3 >> 2 // [0000 0011] ==> [0000 0000] ==> 0
	fmt.Println(a)
	b := 3 << 2 // [0000 0011] ==> [0000 1100] ==> 12
	fmt.Println(b)

}
```
